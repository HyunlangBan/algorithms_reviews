## Mycode (FAIL)
```python
num = int(input())
stack = []
signs = []
current = 1
top = False

for _ in range(num):
  user_input = int(input())
  

  while top == False:
    if len(stack) != 0 and stack[-1] == user_input:
      break
    stack.append(current)
    current += 1
    signs.append('+')
    print(stack)

  if user_input == num:
    top = True

  try:
    stack.pop()
    print(stack)
    signs.append('-')
  except:
    signs = ["NO"]
```
성공하는 케이스에 맞추면 실패하는 케이스에 안맞고, 실패하는 케이스에 맞추면 성공하는 케이스에 안맞고.......
</br>
머리에 지우개가 들었나.......👊🏻

### 간과한부분
문제 해결 포인트는 2개이다.
- 특정 수에 도달할 때까지 원소를 삽입한다.
- 스택에서 원소를 연달아 빼낼때 내림차순을 유지할 수 있는지 확인한다.

두번째 포인트를 어떻게 구현해야할지 헤메다가 결국 해결을 못하고 끝났다.. 또한 특정 수에 도달할때까지 원소를 삽입할때 `!=`조건이 아니라, `<=`조건을 해야했다. 그렇게 되면 삽입된 숫자가 뽑으려는 숫자보다 크다면 pop을 진행할 수 있고 만약 남아있는 스택에 해당 숫자가 없다면 이미 뽑히고 없는 숫자를 다시 뽑으려는 것이기 때문에 NO를 print하면 된다.

## Review2 - Fail
- 문제 이해하는 것도 오래 걸렸다. 정말 기억속에서 다 지워졌나보다...
- 문제에서의 조건은 `스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자.`이고 이는 문제 해결의 두번째 포인트인 `스택에서 원소를 연달아 빼낼대 내림차순을 유지할 수 있는지 확인`과 연관된다. push를 오름차순으로 해야하기 때문에 방향이 반대인 pop은 그 반대인 내림차순이 되어야 하는 것이다. 말로 정리해보면 당연하게 들리는데 이 부분을 이해하는게 어려웠다;;
- 그리고 수열을 일단 다 list에 저장해두고 1부터 n까지 넣으면서 비교를 해야하나 고민했는데 그냥 둘이 같이 하면 되는거였다. 
